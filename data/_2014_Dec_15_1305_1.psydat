ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Users/patrickbissett/OneDrive/Poldrack/PsychoPy/data/_2014_Dec_15_1305
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'LearningTask'
p11
sS'dataNames'
p12
(lp13
S'ok1.keys'
p14
aS'ok1.rt'
p15
aS'resp.keys'
p16
aS'resp.corr'
p17
aS'resp.rt'
p18
asS'autoLog'
p19
I01
sS'extraInfo'
p20
(dp21
S'expName'
p22
g11
sS'gender (m/f)'
p23
V
sS'age'
p24
V
sS'frameRate'
p25
cnumpy.core.multiarray
scalar
p26
(cnumpy
dtype
p27
(S'f8'
I0
I1
tRp28
(I3
S'<'
NNNI-1
I-1
I0
tbS'\xc6\xdf.\x80\xda\xffM@'
tRp29
sS'session'
p30
I3
sS'date'
p31
V2014_Dec_15_1305
p32
sS'participant'
p33
V
ssS'loopsUnfinished'
p34
(lp35
g1
(cpsychopy.data
TrialHandler
p36
g3
NtRp37
(dp38
S'origin'
p39
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.02), Mon Dec 15 13:02:58 2014\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'LearningTask'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'gender (m/f)':'', 'age':'', 'session':03}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + u'data' + os.sep + '%s_%s' %(expInfo['participant'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.WARNING)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "instrPractice"\u000ainstrPracticeClock = core.Clock()\u000ainstruct1 = visual.TextStim(win=win, ori=0, name='instruct1',\u000a    text="In this experiment you will be presented with a large letter made up of smaller letters. Your task is to\u005cn\u005cnRespond by pressing;\u005cn - 'S' if the SMALL letters are S\u005cn - 'H' if the SMALL letters are H\u005cn\u005cnTry to respond as quickly and as accurately as possible.\u005cn\u005cnThere will be a number of practice trials in which you will be given feedback. \u005cn\u005cnPress any key when you are ready to proceed.",    font='Arial',\u000a    pos=[0, 0], height=0.075, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apolygon = visual.Rect(win=win, name='polygon',units='pix', \u000a    width=[1.0, 1.0][0], height=[1.0, 1.0][1],\u000a    ori=1.0, pos=[0,0],\u000a    lineWidth=5, lineColor=[1,70,1], lineColorSpace='rgb',\u000a    fillColor=[1,70,1], fillColorSpace='rgb',\u000a    opacity=1.0,interpolate=True)\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "feedback"\u000afeedbackClock = core.Clock()\u000a#msg variable just needs some value at start\u000amsg=''\u000afeedback_2 = visual.TextStim(win=win, ori=0, name='feedback_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "instrMain"\u000ainstrMainClock = core.Clock()\u000ainstr2 = visual.TextStim(win=win, ori=0, name='instr2',\u000a    text="OK, ready to start the main experiment?\u005cn\u005cnRemember, press;\u005cn - 'S' if the SMALL letters are S\u005cn - 'H' if the SMALL letters are H\u005cn\u005cnTry to respond as quickly and as accurately as possible.\u005cn\u005cnWhen you are ready to proceed press any key.",    font='Arial',\u000a    pos=[0, 0], height=0.075, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apolygon = visual.Rect(win=win, name='polygon',units='pix', \u000a    width=[1.0, 1.0][0], height=[1.0, 1.0][1],\u000a    ori=1.0, pos=[0,0],\u000a    lineWidth=5, lineColor=[1,1,1], lineColorSpace='rgb',\u000a    fillColor=[1,1,1], fillColorSpace='rgb',\u000a    opacity=1.0,interpolate=True)\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "thanks"\u000athanksClock = core.Clock()\u000athanksMsg = visual.TextStim(win=win, ori=0, name='thanksMsg',\u000a    text="You're done! Fun, wasn't it!? ;-)",    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instrPractice"-------\u000at = 0\u000ainstrPracticeClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aok1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000aok1.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstrPracticeComponents = []\u000ainstrPracticeComponents.append(instruct1)\u000ainstrPracticeComponents.append(ok1)\u000afor thisComponent in instrPracticeComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instrPractice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instrPracticeClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruct1* updates\u000a    if t >= 0.0 and instruct1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruct1.tStart = t  # underestimates by a little under one frame\u000a        instruct1.frameNStart = frameN  # exact frame index\u000a        instruct1.setAutoDraw(True)\u000a    \u000a    # *ok1* updates\u000a    if t >= 0.0 and ok1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        ok1.tStart = t  # underestimates by a little under one frame\u000a        ok1.frameNStart = frameN  # exact frame index\u000a        ok1.status = STARTED\u000a        # keyboard checking is just starting\u000a        ok1.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if ok1.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            ok1.keys = theseKeys[-1]  # just the last key pressed\u000a            ok1.rt = ok1.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instrPracticeComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instrPractice"-------\u000afor thisComponent in instrPracticeComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif ok1.keys in ['', [], None]:  # No response was made\u000a   ok1.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('ok1.keys',ok1.keys)\u000aif ok1.keys != None:  # we had a response\u000a    thisExp.addData('ok1.rt', ok1.rt)\u000athisExp.nextEntry()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apracticeTrials = data.TrialHandler(nReps=1.0, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('trialTypes2.xlsx'),\u000a    seed=None, name='practiceTrials')\u000athisExp.addLoop(practiceTrials)  # add the loop to the experiment\u000athisPracticeTrial = practiceTrials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPracticeTrial.rgb)\u000aif thisPracticeTrial != None:\u000a    for paramName in thisPracticeTrial.keys():\u000a        exec(paramName + '= thisPracticeTrial.' + paramName)\u000a\u000afor thisPracticeTrial in practiceTrials:\u000a    currentLoop = practiceTrials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPracticeTrial.rgb)\u000a    if thisPracticeTrial != None:\u000a        for paramName in thisPracticeTrial.keys():\u000a            exec(paramName + '= thisPracticeTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.500000)\u000a    # update component parameters for each repeat\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    polygon.setOpacity(1)\u000a    polygon.setPos([xPos, yPos])\u000a    polygon.setLineWidth(5)\u000a    polygon.setOri(0)\u000a    polygon.setSize([200, 200])\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(resp)\u000a    trialComponents.append(polygon)\u000a    trialComponents.append(text)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *resp* updates\u000a        if t >= .5 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if resp.status == STARTED and t >= (.5 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['t', 'y', 'g', 'h'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(corrAns)) or (resp.keys == corrAns):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *polygon* updates\u000a        if t >= .5 and polygon.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            polygon.tStart = t  # underestimates by a little under one frame\u000a            polygon.frameNStart = frameN  # exact frame index\u000a            polygon.setAutoDraw(True)\u000a        if polygon.status == STARTED and t >= (.5 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            polygon.setAutoDraw(False)\u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        if text.status == STARTED and t >= (0.0 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practiceTrials (TrialHandler)\u000a    practiceTrials.addData('resp.keys',resp.keys)\u000a    practiceTrials.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        practiceTrials.addData('resp.rt', resp.rt)\u000a    \u000a    #------Prepare to start Routine "feedback"-------\u000a    t = 0\u000a    feedbackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if resp.corr:#stored on last run routine\u000a      msg="Correct! RT=%.3f" %(resp.rt)\u000a    else:\u000a      msg="Oops! That was wrong"\u000a    feedback_2.setText(msg)\u000a    # keep track of which components have finished\u000a    feedbackComponents = []\u000a    feedbackComponents.append(feedback_2)\u000a    for thisComponent in feedbackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "feedback"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = feedbackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *feedback_2* updates\u000a        if t >= 0.0 and feedback_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            feedback_2.tStart = t  # underestimates by a little under one frame\u000a            feedback_2.frameNStart = frameN  # exact frame index\u000a            feedback_2.setAutoDraw(True)\u000a        if feedback_2.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            feedback_2.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in feedbackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "feedback"-------\u000a    for thisComponent in feedbackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1.0 repeats of 'practiceTrials'\u000a\u000a# get names of stimulus parameters\u000aif practiceTrials.trialList in ([], [None], None):  params = []\u000aelse:  params = practiceTrials.trialList[0].keys()\u000a# save data for this loop\u000apracticeTrials.saveAsExcel(filename + '.xlsx', sheetName='practiceTrials',\u000a    stimOut=params,\u000a    dataOut=['n','all_mean','all_std', 'all_raw'])\u000a\u000a#------Prepare to start Routine "instrMain"-------\u000at = 0\u000ainstrMainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aok2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000aok2.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstrMainComponents = []\u000ainstrMainComponents.append(instr2)\u000ainstrMainComponents.append(ok2)\u000afor thisComponent in instrMainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instrMain"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instrMainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr2* updates\u000a    if t >= 0.0 and instr2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr2.tStart = t  # underestimates by a little under one frame\u000a        instr2.frameNStart = frameN  # exact frame index\u000a        instr2.setAutoDraw(True)\u000a    \u000a    # *ok2* updates\u000a    if t >= 0.0 and ok2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        ok2.tStart = t  # underestimates by a little under one frame\u000a        ok2.frameNStart = frameN  # exact frame index\u000a        ok2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if ok2.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instrMainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instrMain"-------\u000afor thisComponent in instrMainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atrials = data.TrialHandler(nReps=4.0, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('trialTypes2.xlsx'),\u000a    seed=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experiment\u000athisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000aif thisTrial != None:\u000a    for paramName in thisTrial.keys():\u000a        exec(paramName + '= thisTrial.' + paramName)\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.500000)\u000a    # update component parameters for each repeat\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    polygon.setOpacity(1)\u000a    polygon.setPos([xPos, yPos])\u000a    polygon.setLineWidth(5)\u000a    polygon.setOri(0)\u000a    polygon.setSize([200, 200])\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(resp)\u000a    trialComponents.append(polygon)\u000a    trialComponents.append(text)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *resp* updates\u000a        if t >= .5 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if resp.status == STARTED and t >= (.5 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['t', 'y', 'g', 'h'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(corrAns)) or (resp.keys == corrAns):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *polygon* updates\u000a        if t >= .5 and polygon.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            polygon.tStart = t  # underestimates by a little under one frame\u000a            polygon.frameNStart = frameN  # exact frame index\u000a            polygon.setAutoDraw(True)\u000a        if polygon.status == STARTED and t >= (.5 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            polygon.setAutoDraw(False)\u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        if text.status == STARTED and t >= (0.0 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for trials (TrialHandler)\u000a    trials.addData('resp.keys',resp.keys)\u000a    trials.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        trials.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a    \u000a# completed 4.0 repeats of 'trials'\u000a\u000a# get names of stimulus parameters\u000aif trials.trialList in ([], [None], None):  params = []\u000aelse:  params = trials.trialList[0].keys()\u000a# save data for this loop\u000atrials.saveAsExcel(filename + '.xlsx', sheetName='trials',\u000a    stimOut=params,\u000a    dataOut=['n','all_mean','all_std', 'all_raw'])\u000a\u000a#------Prepare to start Routine "thanks"-------\u000at = 0\u000athanksClock.reset()  # clock \u000aframeN = -1\u000aroutineTimer.add(2.000000)\u000a# update component parameters for each repeat\u000a# keep track of which components have finished\u000athanksComponents = []\u000athanksComponents.append(thanksMsg)\u000afor thisComponent in thanksComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thanks"-------\u000acontinueRoutine = True\u000awhile continueRoutine and routineTimer.getTime() > 0:\u000a    # get current time\u000a    t = thanksClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thanksMsg* updates\u000a    if t >= 0.0 and thanksMsg.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thanksMsg.tStart = t  # underestimates by a little under one frame\u000a        thanksMsg.frameNStart = frameN  # exact frame index\u000a        thanksMsg.setAutoDraw(True)\u000a    if thanksMsg.status == STARTED and t >= (0.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        thanksMsg.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thanksComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "thanks"-------\u000afor thisComponent in thanksComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a
p40
sS'thisTrial'
p41
g1
(cpsychopy.data
TrialType
p42
c__builtin__
dict
p43
(dp44
VxPos
p45
I-200
sVcorrAns
p46
Vg
sVlocation
p47
Vdown_left
p48
sVShape
p49
VTriangle
p50
sVnumVertices
p51
I3
sVyPos
p52
I-200
stRp53
sS'_exp'
p54
I219857744
sg10
S'practiceTrials'
p55
sg6
S'/Users/patrickbissett/OneDrive/Poldrack/PsychoPy/LearningTask.py'
p56
sS'thisRepN'
p57
I0
sg19
I01
sg20
g21
sS'data'
p58
g1
(cpsychopy.data
DataHandler
p59
g43
(dp60
S'ran'
p61
cnumpy.ma.core
_mareconstruct
p62
(cnumpy.ma.core
MaskedArray
p63
cnumpy
ndarray
p64
(I0
tp65
S'b'
tRp66
(I1
(I16
I1
tg27
(S'f4'
I0
I1
tRp67
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg16
cnumpy.core.multiarray
_reconstruct
p68
(g64
(I0
tS'b'
tRp69
(I1
(I16
I1
tg27
(S'O4'
I0
I1
tRp70
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp71
S'--'
p72
aS'--'
p73
aS'--'
p74
aS'--'
p75
aS'--'
p76
aS'--'
p77
aS'--'
p78
aS't'
aS'--'
p79
aS'--'
p80
aS'--'
p81
aS'--'
p82
aS'--'
p83
aS'g'
aS'--'
p84
aS'--'
p85
atbsg17
g62
(g63
g64
g65
S'b'
tRp86
(I1
(I16
I1
tg67
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x01\x01\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x00\x01\x01'
NtbsS'order'
p87
g62
(g63
g64
g65
S'b'
tRp88
(I1
(I16
I1
tg67
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x01\x01\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x00\x01\x01'
Ntbsg18
g62
(g63
g64
g65
S'b'
tRp89
(I1
(I16
I1
tg67
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x90\\\xe6>\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00P\xcf\xaa>\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x01\x01\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x00\x01\x01'
NtbstRp90
(dp91
S'isNumeric'
p92
(dp93
g61
I01
sg16
I00
sg18
I01
sg87
I01
sg17
I01
ssS'trials'
p94
g37
sS'dataTypes'
p95
(lp96
g61
ag87
ag16
ag17
ag18
asS'dataShape'
p97
(lp98
I16
aI1
asbsS'method'
p99
S'random'
p100
sS'sequenceIndices'
p101
g68
(g64
(I0
tS'b'
tRp102
(I1
(I16
I1
tg27
(S'i4'
I0
I1
tRp103
(I3
S'<'
NNNI-1
I-1
I0
tbI01
S'\x07\x00\x00\x00\r\x00\x00\x00\x06\x00\x00\x00\x0b\x00\x00\x00\x0f\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\x08\x00\x00\x00\x0e\x00\x00\x00\x00\x00\x00\x00\x0c\x00\x00\x00\n\x00\x00\x00\t\x00\x00\x00'
tbsS'finished'
p104
I00
sS'nReps'
p105
I1
sS'nRemaining'
p106
I14
sS'trialList'
p107
(lp108
g1
(g42
g43
(dp109
g45
I200
sg46
Vy
sg47
Vup_right
p110
sg49
VLine
p111
sg51
I2
sg52
I200
stRp112
ag1
(g42
g43
(dp113
g45
I200
sg46
Vy
sg47
g110
sg49
g50
sg51
I3
sg52
I200
stRp114
ag1
(g42
g43
(dp115
g45
I200
sg46
Vy
sg47
g110
sg49
VSquare
p116
sg51
I4
sg52
I200
stRp117
ag1
(g42
g43
(dp118
g45
I200
sg46
Vy
sg47
g110
sg49
VCircle
p119
sg51
I90
sg52
I200
stRp120
ag1
(g42
g43
(dp121
g45
I-200
sg46
Vt
sg47
Vup_left
p122
sg49
g111
sg51
I2
sg52
I200
stRp123
ag1
(g42
g43
(dp124
g45
I-200
sg46
Vt
sg47
g122
sg49
g50
sg51
I3
sg52
I200
stRp125
ag1
(g42
g43
(dp126
g45
I-200
sg46
Vt
sg47
g122
sg49
g116
sg51
I4
sg52
I200
stRp127
ag1
(g42
g43
(dp128
g45
I-200
sg46
Vt
sg47
g122
sg49
g119
sg51
I90
sg52
I200
stRp129
ag1
(g42
g43
(dp130
g45
I200
sg46
Vh
sg47
Vdown_right
p131
sg49
g111
sg51
I2
sg52
I-200
stRp132
ag1
(g42
g43
(dp133
g45
I200
sg46
Vh
sg47
g131
sg49
g50
sg51
I3
sg52
I-200
stRp134
ag1
(g42
g43
(dp135
g45
I200
sg46
Vh
sg47
g131
sg49
g116
sg51
I4
sg52
I-200
stRp136
ag1
(g42
g43
(dp137
g45
I200
sg46
Vh
sg47
g131
sg49
g119
sg51
I90
sg52
I-200
stRp138
ag1
(g42
g43
(dp139
g45
I-200
sg46
Vg
sg47
g48
sg49
g111
sg51
I2
sg52
I-200
stRp140
ag53
ag1
(g42
g43
(dp141
g45
I-200
sg46
Vg
sg47
g48
sg49
g116
sg51
I4
sg52
I-200
stRp142
ag1
(g42
g43
(dp143
g45
I-200
sg46
Vg
sg47
g48
sg49
g119
sg51
I90
sg52
I-200
stRp144
asS'seed'
p145
NsS'thisIndex'
p146
g26
(g103
S'\r\x00\x00\x00'
tRp147
sS'thisN'
p148
I1
sS'thisTrialN'
p149
I1
sS'nTotal'
p150
I16
sS'_warnUseOfNext'
p151
I01
sbasS'saveWideText'
p152
I01
sS'thisEntry'
p153
(dp154
g16
S'g'
sg18
F0.33361291885375977
sg17
I1
ssS'version'
p155
S''
sS'_paramNamesSoFar'
p156
(lp157
g45
ag47
ag49
ag52
ag51
ag46
asS'entries'
p158
(lp159
(dp160
g30
I3
sg23
V
sg15
F0.84095501899719238
sg24
V
sg25
g29
sg22
g11
sg14
S'g'
sg31
g32
sg33
V
sa(dp161
g30
I3
sg16
S't'
sg45
I-200
sg46
Vt
sg17
I1
sg18
F0.44992494583129883
sg24
V
sg33
V
sS'practiceTrials.thisN'
p162
I0
sg52
I200
sg25
g29
sg31
g32
sg49
g119
sg22
g11
sS'practiceTrials.thisTrialN'
p163
I0
sS'practiceTrials.thisIndex'
p164
g26
(g103
S'\x07\x00\x00\x00'
tRp165
sS'practiceTrials.thisRepN'
p166
I0
sg23
V
sg51
I90
sg47
g122
sasS'loops'
p167
(lp168
g37
asS'savePickle'
p169
I01
sb.