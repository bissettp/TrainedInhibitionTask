ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Users/patrickbissett/OneDrive/Poldrack/TrainedInhibition/PsychoPy/data/47_2015_Mar_05_1317
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'LearningTask'
p11
sS'dataNames'
p12
(lp13
S'ok1.keys'
p14
aS'ok1.rt'
p15
aS'resp.keys'
p16
aS'resp.corr'
p17
aS'resp.rt'
p18
asS'autoLog'
p19
I01
sS'extraInfo'
p20
(dp21
S'expName'
p22
g11
sS'gender (m/f)'
p23
V
sS'age'
p24
V
sS'frameRate'
p25
cnumpy.core.multiarray
scalar
p26
(cnumpy
dtype
p27
(S'f8'
I0
I1
tRp28
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x13j\xd2\x0f\t\xfaM@'
tRp29
sS'session'
p30
I3
sS'date'
p31
V2015_Mar_05_1317
p32
sS'participant'
p33
V47
p34
ssS'loopsUnfinished'
p35
(lp36
g1
(cpsychopy.data
TrialHandler
p37
g3
NtRp38
(dp39
S'origin'
p40
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.03), Thu Mar  5 13:17:06 2015\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'LearningTask'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'gender (m/f)':'', 'age':'', 'session':03}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + u'data' + os.sep + '%s_%s' %(expInfo['participant'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.WARNING)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(2560, 1440), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "StimSetup"\u000aStimSetupClock = core.Clock()\u000acolors = ['yellow', 'white', 'orange', 'magenta', 'green', 'gray', 'cyan', 'blue']\u000ashapes = ['triangle', 'square', 'line', 'invertedTriangle', 'hexagon', 'diamond', 'cross', 'circle']\u000arewards = [0.5, 1, 2, 4] * 2\u000aconditions = ['go', 'go', 'go', 'go', 'stop', 'stop', 'stop', 'stop']\u000atrialDetailsList = []\u000a\u000ashuffle(colors)\u000ashuffle(shapes)\u000a\u000afor i, color in enumerate(colors): # cycle through each color and keep track of an index number\u000a    trialDetails = {} # a dictionary of key-value pairs\u000a    trialDetails['fileName'] = shapes[i] + color + '.gif'\u000a    trialDetails['reward'] = rewards[i]\u000a    trialDetails['condition'] = conditions[i]\u000a    trialDetailsList.append(trialDetails)\u000a\u000ashuffle(trialDetailsList) # do this now to ensure that order of presentation of rewards and conditions is also shuffled\u000a\u000aConditionOne = trialDetailsList[0]\u000aConditionTwo = trialDetailsList[1]\u000aConditionThree = trialDetailsList[2]\u000aConditionFour = trialDetailsList[3]\u000aConditionFive = trialDetailsList[4]\u000aConditionSix = trialDetailsList[5]\u000aConditionSeven = trialDetailsList[6]\u000aConditionEight = trialDetailsList[7]\u000a\u000a# Initialize components for Routine "instrPractice"\u000ainstrPracticeClock = core.Clock()\u000ainstruct1 = visual.TextStim(win=win, ori=0, name='instruct1',\u000a    text=u'A shape stimulus will appear on every trial. \u005cn\u005cnIf it appears in the upper right quadrant, PRESS Y\u005cn\u005cnIf it appears in the lower right quadrant, PRESS H\u005cn\u005cnIf it appears in the lower left quadrant, PRESS G\u005cn\u005cnIf it appears in the upper left quadrant, PRESS T\u005cn\u005cnPress any key when you are ready to proceed. ',    font=u'Arial',\u000a    pos=[0, 0], height=0.07, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage_2 = visual.ImageStim(win=win, name='image_2',units='pix', \u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[101, 101],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "feedback"\u000afeedbackClock = core.Clock()\u000a#msg variable just needs some value at start\u000amsg=''\u000afeedback_2 = visual.TextStim(win=win, ori=0, name='feedback_2',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "instrMain"\u000ainstrMainClock = core.Clock()\u000ainstr2 = visual.TextStim(win=win, ori=0, name='instr2',\u000a    text="OK, ready to start the main experiment?\u005cn\u005cnRemember, press;\u005cn - 'S' if the SMALL letters are S\u005cn - 'H' if the SMALL letters are H\u005cn\u005cnTry to respond as quickly and as accurately as possible.\u005cn\u005cnWhen you are ready to proceed press any key.",    font='Arial',\u000a    pos=[0, 0], height=0.075, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage_2 = visual.ImageStim(win=win, name='image_2',units='pix', \u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[101, 101],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "StimSetup"-------\u000at = 0\u000aStimSetupClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aStimSetupComponents = []\u000afor thisComponent in StimSetupComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "StimSetup"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = StimSetupClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in StimSetupComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "StimSetup"-------\u000afor thisComponent in StimSetupComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a#------Prepare to start Routine "instrPractice"-------\u000at = 0\u000ainstrPracticeClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aok1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000aok1.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstrPracticeComponents = []\u000ainstrPracticeComponents.append(instruct1)\u000ainstrPracticeComponents.append(ok1)\u000afor thisComponent in instrPracticeComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instrPractice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instrPracticeClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruct1* updates\u000a    if t >= 0.0 and instruct1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruct1.tStart = t  # underestimates by a little under one frame\u000a        instruct1.frameNStart = frameN  # exact frame index\u000a        instruct1.setAutoDraw(True)\u000a    \u000a    # *ok1* updates\u000a    if t >= 0.0 and ok1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        ok1.tStart = t  # underestimates by a little under one frame\u000a        ok1.frameNStart = frameN  # exact frame index\u000a        ok1.status = STARTED\u000a        # keyboard checking is just starting\u000a        ok1.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if ok1.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            ok1.keys = theseKeys[-1]  # just the last key pressed\u000a            ok1.rt = ok1.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instrPracticeComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instrPractice"-------\u000afor thisComponent in instrPracticeComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif ok1.keys in ['', [], None]:  # No response was made\u000a   ok1.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('ok1.keys',ok1.keys)\u000aif ok1.keys != None:  # we had a response\u000a    thisExp.addData('ok1.rt', ok1.rt)\u000athisExp.nextEntry()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apracticeTrials = data.TrialHandler(nReps=1.0, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'Trialtypes4.xlsx'),\u000a    seed=None, name='practiceTrials')\u000athisExp.addLoop(practiceTrials)  # add the loop to the experiment\u000athisPracticeTrial = practiceTrials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPracticeTrial.rgb)\u000aif thisPracticeTrial != None:\u000a    for paramName in thisPracticeTrial.keys():\u000a        exec(paramName + '= thisPracticeTrial.' + paramName)\u000a\u000afor thisPracticeTrial in practiceTrials:\u000a    currentLoop = practiceTrials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPracticeTrial.rgb)\u000a    if thisPracticeTrial != None:\u000a        for paramName in thisPracticeTrial.keys():\u000a            exec(paramName + '= thisPracticeTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.500000)\u000a    # update component parameters for each repeat\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    image_2.setPos([xPos, yPos])\u000a    image_2.setImage(ShapeStimulus)\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(resp)\u000a    trialComponents.append(text)\u000a    trialComponents.append(image_2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *resp* updates\u000a        if t >= .5 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if resp.status == STARTED and t >= (.5 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['t', 'y', 'g', 'h'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(corrAns)) or (resp.keys == corrAns):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        if text.status == STARTED and t >= (0.0 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # *image_2* updates\u000a        if t >= .5 and image_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            image_2.tStart = t  # underestimates by a little under one frame\u000a            image_2.frameNStart = frameN  # exact frame index\u000a            image_2.setAutoDraw(True)\u000a        if image_2.status == STARTED and t >= (.5 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            image_2.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practiceTrials (TrialHandler)\u000a    practiceTrials.addData('resp.keys',resp.keys)\u000a    practiceTrials.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        practiceTrials.addData('resp.rt', resp.rt)\u000a    \u000a    #------Prepare to start Routine "feedback"-------\u000a    t = 0\u000a    feedbackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if resp.corr:#stored on last run routine\u000a      msg="Correct! RT=%.3f" %(resp.rt)\u000a    else:\u000a      msg="Oops! That was wrong"\u000a    feedback_2.setText(u'reward')\u000a    # keep track of which components have finished\u000a    feedbackComponents = []\u000a    feedbackComponents.append(feedback_2)\u000a    for thisComponent in feedbackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "feedback"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = feedbackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *feedback_2* updates\u000a        if t >= 0.0 and feedback_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            feedback_2.tStart = t  # underestimates by a little under one frame\u000a            feedback_2.frameNStart = frameN  # exact frame index\u000a            feedback_2.setAutoDraw(True)\u000a        if feedback_2.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            feedback_2.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in feedbackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "feedback"-------\u000a    for thisComponent in feedbackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1.0 repeats of 'practiceTrials'\u000a\u000a# get names of stimulus parameters\u000aif practiceTrials.trialList in ([], [None], None):  params = []\u000aelse:  params = practiceTrials.trialList[0].keys()\u000a# save data for this loop\u000apracticeTrials.saveAsExcel(filename + '.xlsx', sheetName='practiceTrials',\u000a    stimOut=params,\u000a    dataOut=['n','all_mean','all_std', 'all_raw'])\u000a\u000a#------Prepare to start Routine "instrMain"-------\u000at = 0\u000ainstrMainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aok2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000aok2.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstrMainComponents = []\u000ainstrMainComponents.append(instr2)\u000ainstrMainComponents.append(ok2)\u000afor thisComponent in instrMainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instrMain"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instrMainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr2* updates\u000a    if t >= 0.0 and instr2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr2.tStart = t  # underestimates by a little under one frame\u000a        instr2.frameNStart = frameN  # exact frame index\u000a        instr2.setAutoDraw(True)\u000a    \u000a    # *ok2* updates\u000a    if t >= 0.0 and ok2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        ok2.tStart = t  # underestimates by a little under one frame\u000a        ok2.frameNStart = frameN  # exact frame index\u000a        ok2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if ok2.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instrMainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instrMain"-------\u000afor thisComponent in instrMainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atrials = data.TrialHandler(nReps=4.0, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'Trialtypes4.xlsx'),\u000a    seed=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experiment\u000athisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000aif thisTrial != None:\u000a    for paramName in thisTrial.keys():\u000a        exec(paramName + '= thisTrial.' + paramName)\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.500000)\u000a    # update component parameters for each repeat\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    image_2.setPos([xPos, yPos])\u000a    image_2.setImage(ShapeStimulus)\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(resp)\u000a    trialComponents.append(text)\u000a    trialComponents.append(image_2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *resp* updates\u000a        if t >= .5 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if resp.status == STARTED and t >= (.5 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['t', 'y', 'g', 'h'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(corrAns)) or (resp.keys == corrAns):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        if text.status == STARTED and t >= (0.0 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # *image_2* updates\u000a        if t >= .5 and image_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            image_2.tStart = t  # underestimates by a little under one frame\u000a            image_2.frameNStart = frameN  # exact frame index\u000a            image_2.setAutoDraw(True)\u000a        if image_2.status == STARTED and t >= (.5 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            image_2.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for trials (TrialHandler)\u000a    trials.addData('resp.keys',resp.keys)\u000a    trials.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        trials.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a    \u000a# completed 4.0 repeats of 'trials'\u000a\u000a# get names of stimulus parameters\u000aif trials.trialList in ([], [None], None):  params = []\u000aelse:  params = trials.trialList[0].keys()\u000a# save data for this loop\u000atrials.saveAsExcel(filename + '.xlsx', sheetName='trials',\u000a    stimOut=params,\u000a    dataOut=['n','all_mean','all_std', 'all_raw'])\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p41
sS'thisTrial'
p42
g1
(cpsychopy.data
TrialType
p43
c__builtin__
dict
p44
(dp45
VxPos
p46
I200
sVcorrAns
p47
Vy
sVlocation
p48
Vup_right
p49
sVShapeStimulus
p50
V$crosscyan.gif
p51
sVShape
p52
VLine
p53
sVyPos
p54
I200
stRp55
sS'_exp'
p56
I232587664
sg10
S'practiceTrials'
p57
sg6
S'/Users/patrickbissett/OneDrive/Poldrack/TrainedInhibition/PsychoPy/IntegratingDifferentCode3-5-15.py'
p58
sS'thisRepN'
p59
I0
sg19
I01
sg20
g21
sS'data'
p60
g1
(cpsychopy.data
DataHandler
p61
g44
(dp62
S'ran'
p63
cnumpy.ma.core
_mareconstruct
p64
(cnumpy.ma.core
MaskedArray
p65
cnumpy
ndarray
p66
(I0
tp67
S'b'
tRp68
(I1
(I32
I1
tg27
(S'f4'
I0
I1
tRp69
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg16
cnumpy.core.multiarray
_reconstruct
p70
(g66
(I0
tS'b'
tRp71
(I1
(I32
I1
tg27
(S'O4'
I0
I1
tRp72
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp73
S'--'
p74
aS'--'
p75
aS'--'
p76
aS'--'
p77
aS'--'
p78
aS'--'
p79
aS'--'
p80
aS'--'
p81
aS'--'
p82
aS'--'
p83
aS'--'
p84
aS'--'
p85
aS'--'
p86
aS'--'
p87
aS'--'
p88
aS'--'
p89
aS'--'
p90
aS'--'
p91
aS'--'
p92
aS'--'
p93
aS'h'
aS'--'
p94
aS'--'
p95
aS'--'
p96
aS'--'
p97
aS'--'
p98
aS'--'
p99
aS'--'
p100
aS'--'
p101
aS'--'
p102
aS'--'
p103
aS'--'
p104
atbsg17
g64
(g65
g66
g67
S'b'
tRp105
(I1
(I32
I1
tg69
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01'
NtbsS'order'
p106
g64
(g65
g66
g67
S'b'
tRp107
(I1
(I32
I1
tg69
I00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01'
Ntbsg18
g64
(g65
g66
g67
S'b'
tRp108
(I1
(I32
I1
tg69
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xbcyb?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01'
NtbstRp109
(dp110
S'isNumeric'
p111
(dp112
g63
I01
sg16
I00
sg18
I01
sg106
I01
sg17
I01
ssS'trials'
p113
g38
sS'dataTypes'
p114
(lp115
g63
ag106
ag16
ag17
ag18
asS'dataShape'
p116
(lp117
I32
aI1
asbsS'method'
p118
S'random'
p119
sS'sequenceIndices'
p120
g70
(g66
(I0
tS'b'
tRp121
(I1
(I32
I1
tg27
(S'i4'
I0
I1
tRp122
(I3
S'<'
NNNI-1
I-1
I0
tbI01
S'\x14\x00\x00\x00\x00\x00\x00\x00\x11\x00\x00\x00\x0c\x00\x00\x00\x06\x00\x00\x00\x18\x00\x00\x00\t\x00\x00\x00\x1c\x00\x00\x00\x05\x00\x00\x00\x02\x00\x00\x00\x08\x00\x00\x00\x15\x00\x00\x00\x1f\x00\x00\x00\x19\x00\x00\x00\x13\x00\x00\x00\x03\x00\x00\x00\x1e\x00\x00\x00\x04\x00\x00\x00\x1a\x00\x00\x00\x0b\x00\x00\x00\x0f\x00\x00\x00\x1b\x00\x00\x00\x16\x00\x00\x00\x1d\x00\x00\x00\n\x00\x00\x00\x0e\x00\x00\x00\x07\x00\x00\x00\r\x00\x00\x00\x12\x00\x00\x00\x10\x00\x00\x00\x17\x00\x00\x00\x01\x00\x00\x00'
tbsS'finished'
p123
I00
sS'nReps'
p124
I1
sS'nRemaining'
p125
I30
sS'trialList'
p126
(lp127
g55
ag1
(g43
g44
(dp128
g46
I200
sg47
Vy
sg48
g49
sg50
Vcrossgray.gif
p129
sg52
VTriangle
p130
sg54
I200
stRp131
ag1
(g43
g44
(dp132
g46
I200
sg47
Vy
sg48
g49
sg50
Vcrossorange.gif
p133
sg52
VSquare
p134
sg54
I200
stRp135
ag1
(g43
g44
(dp136
g46
I200
sg47
Vy
sg48
g49
sg50
Vcrossyellow.gif
p137
sg52
VCircle
p138
sg54
I200
stRp139
ag1
(g43
g44
(dp140
g46
I200
sg47
Vy
sg48
Nsg50
Nsg52
Nsg54
I200
stRp141
ag1
(g43
g44
(dp142
g46
I200
sg47
Vy
sg48
Nsg50
Nsg52
Nsg54
I200
stRp143
ag1
(g43
g44
(dp144
g46
I200
sg47
Vy
sg48
Nsg50
Nsg52
Nsg54
I200
stRp145
ag1
(g43
g44
(dp146
g46
I200
sg47
Vy
sg48
Nsg50
Nsg52
Nsg54
I200
stRp147
ag1
(g43
g44
(dp148
g46
I-200
sg47
Vt
sg48
Vup_left
p149
sg50
Vcirclegreen.gif
p150
sg52
g53
sg54
I200
stRp151
ag1
(g43
g44
(dp152
g46
I-200
sg47
Vt
sg48
g149
sg50
Vcirclemagenta.gif
p153
sg52
g130
sg54
I200
stRp154
ag1
(g43
g44
(dp155
g46
I-200
sg47
Vt
sg48
g149
sg50
Vcirclewhite.gif
p156
sg52
g134
sg54
I200
stRp157
ag1
(g43
g44
(dp158
g46
I-200
sg47
Vt
sg48
g149
sg50
Vcirclecyan.gif
p159
sg52
g138
sg54
I200
stRp160
ag1
(g43
g44
(dp161
g46
I-200
sg47
Vt
sg48
Nsg50
Nsg52
Nsg54
I200
stRp162
ag1
(g43
g44
(dp163
g46
I-200
sg47
Vt
sg48
Nsg50
Nsg52
Nsg54
I200
stRp164
ag1
(g43
g44
(dp165
g46
I-200
sg47
Vt
sg48
Nsg50
Nsg52
Nsg54
I200
stRp166
ag1
(g43
g44
(dp167
g46
I-200
sg47
Vt
sg48
Nsg50
Nsg52
Nsg54
I200
stRp168
ag1
(g43
g44
(dp169
g46
I200
sg47
Vh
sg48
Vdown_right
p170
sg50
Vdiamondgray.gif
p171
sg52
g53
sg54
I-200
stRp172
ag1
(g43
g44
(dp173
g46
I200
sg47
Vh
sg48
g170
sg50
Vdiamondorange.gif
p174
sg52
g130
sg54
I-200
stRp175
ag1
(g43
g44
(dp176
g46
I200
sg47
Vh
sg48
g170
sg50
Vdiamondwhite.gif
p177
sg52
g134
sg54
I-200
stRp178
ag1
(g43
g44
(dp179
g46
I200
sg47
Vh
sg48
g170
sg50
Vdiamondmagenta.gif
p180
sg52
g138
sg54
I-200
stRp181
ag1
(g43
g44
(dp182
g46
I200
sg47
Vh
sg48
Nsg50
Nsg52
Nsg54
I-200
stRp183
ag1
(g43
g44
(dp184
g46
I200
sg47
Vh
sg48
Nsg50
Nsg52
Nsg54
I-200
stRp185
ag1
(g43
g44
(dp186
g46
I200
sg47
Vh
sg48
Nsg50
Nsg52
Nsg54
I-200
stRp187
ag1
(g43
g44
(dp188
g46
I200
sg47
Vh
sg48
Nsg50
Nsg52
Nsg54
I-200
stRp189
ag1
(g43
g44
(dp190
g46
I-200
sg47
Vg
sg48
Vdown_left
p191
sg50
Vhexagonyellow.gif
p192
sg52
g53
sg54
I-200
stRp193
ag1
(g43
g44
(dp194
g46
I-200
sg47
Vg
sg48
g191
sg50
Vhexagonmagenta.gif
p195
sg52
g130
sg54
I-200
stRp196
ag1
(g43
g44
(dp197
g46
I-200
sg47
Vg
sg48
g191
sg50
Vhexagongreen.gif
p198
sg52
g134
sg54
I-200
stRp199
ag1
(g43
g44
(dp200
g46
I-200
sg47
Vg
sg48
g191
sg50
Vhexagongray.gif
p201
sg52
g138
sg54
I-200
stRp202
ag1
(g43
g44
(dp203
g46
I-200
sg47
Vg
sg48
Nsg50
Nsg52
Nsg54
I-200
stRp204
ag1
(g43
g44
(dp205
g46
I-200
sg47
Vg
sg48
Nsg50
Nsg52
Nsg54
I-200
stRp206
ag1
(g43
g44
(dp207
g46
I-200
sg47
Vg
sg48
Nsg50
Nsg52
Nsg54
I-200
stRp208
ag1
(g43
g44
(dp209
g46
I-200
sg47
Vg
sg48
Nsg50
Nsg52
Nsg54
I-200
stRp210
asS'seed'
p211
NsS'thisIndex'
p212
g26
(g122
S'\x00\x00\x00\x00'
tRp213
sS'thisN'
p214
I1
sS'thisTrialN'
p215
I1
sS'nTotal'
p216
I32
sS'_warnUseOfNext'
p217
I01
sbasS'saveWideText'
p218
I01
sS'thisEntry'
p219
(dp220
sS'version'
p221
S''
sS'_paramNamesSoFar'
p222
(lp223
g46
ag48
ag50
ag52
ag54
ag47
asS'entries'
p224
(lp225
(dp226
g30
I3
sg23
V
sg15
F0.89331889152526855
sg24
V
sg25
g29
sg22
g11
sg14
S'space'
p227
sg31
g32
sg33
g34
sa(dp228
g30
I3
sg16
S'h'
sg46
I200
sg47
Vh
sg50
Nsg17
I1
sg18
F0.88467001914978027
sg24
V
sg33
g34
sS'practiceTrials.thisN'
p229
I0
sg54
I-200
sg25
g29
sg31
g32
sg52
Nsg22
g11
sS'practiceTrials.thisTrialN'
p230
I0
sS'practiceTrials.thisIndex'
p231
g26
(g122
S'\x14\x00\x00\x00'
tRp232
sS'practiceTrials.thisRepN'
p233
I0
sg23
V
sg48
NsasS'loops'
p234
(lp235
g38
asS'savePickle'
p236
I01
sb.