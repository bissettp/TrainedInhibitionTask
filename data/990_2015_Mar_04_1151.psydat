ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Users/patrickbissett/OneDrive/Poldrack/TrainedInhibition/PsychoPy/data/990_2015_Mar_04_1151
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'LearningTask'
p11
sS'dataNames'
p12
(lp13
S'ok1.keys'
p14
aS'ok1.rt'
p15
aS'resp.keys'
p16
aS'resp.corr'
p17
aS'resp.rt'
p18
asS'autoLog'
p19
I01
sS'extraInfo'
p20
(dp21
S'expName'
p22
g11
sS'gender (m/f)'
p23
V
sS'age'
p24
V
sS'frameRate'
p25
cnumpy.core.multiarray
scalar
p26
(cnumpy
dtype
p27
(S'f8'
I0
I1
tRp28
(I3
S'<'
NNNI-1
I-1
I0
tbS'M\xcfe\xf3\x83\x05N@'
tRp29
sS'session'
p30
I3
sS'date'
p31
V2015_Mar_04_1151
p32
sS'participant'
p33
V990
p34
ssS'loopsUnfinished'
p35
(lp36
g1
(cpsychopy.data
TrialHandler
p37
g3
NtRp38
(dp39
S'origin'
p40
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.03), Wed Mar  4 09:28:30 2015\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'LearningTask'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'gender (m/f)':'', 'age':'', 'session':03}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + u'data' + os.sep + '%s_%s' %(expInfo['participant'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.WARNING)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "StimSetup"\u000aStimSetupClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "instrPractice"\u000ainstrPracticeClock = core.Clock()\u000ainstruct1 = visual.TextStim(win=win, ori=0, name='instruct1',\u000a    text='A shape stimulus will appear on every trial. \u005cn\u005cnIf it appears in the upper right quadrant, PRESS Y\u005cn\u005cnIf it appears in the lower right quadrant, PRESS H\u005cn\u005cnIf it appears in the lower left quadrant, PRESS G\u005cn\u005cnIf it appears in the upper left quadrant, PRESS T\u005cn\u005cnPress any key when you are ready to proceed. ',    font='Arial',\u000a    pos=[0, 0], height=0.07, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage_2 = visual.ImageStim(win=win, name='image_2',units='pix', \u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[101, 101],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "feedback"\u000afeedbackClock = core.Clock()\u000a#msg variable just needs some value at start\u000amsg=''\u000afeedback_2 = visual.TextStim(win=win, ori=0, name='feedback_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "instrMain"\u000ainstrMainClock = core.Clock()\u000ainstr2 = visual.TextStim(win=win, ori=0, name='instr2',\u000a    text="OK, ready to start the main experiment?\u005cn\u005cnRemember, press;\u005cn - 'S' if the SMALL letters are S\u005cn - 'H' if the SMALL letters are H\u005cn\u005cnTry to respond as quickly and as accurately as possible.\u005cn\u005cnWhen you are ready to proceed press any key.",    font='Arial',\u000a    pos=[0, 0], height=0.075, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage_2 = visual.ImageStim(win=win, name='image_2',units='pix', \u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[101, 101],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a# set up handler to look after randomisation of conditions etc\u000aColorLoop = data.TrialHandler(nReps=8, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('Color.xlsx'),\u000a    seed=None, name='ColorLoop')\u000athisExp.addLoop(ColorLoop)  # add the loop to the experiment\u000athisColorLoop = ColorLoop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisColorLoop.rgb)\u000aif thisColorLoop != None:\u000a    for paramName in thisColorLoop.keys():\u000a        exec(paramName + '= thisColorLoop.' + paramName)\u000a\u000afor thisColorLoop in ColorLoop:\u000a    currentLoop = ColorLoop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisColorLoop.rgb)\u000a    if thisColorLoop != None:\u000a        for paramName in thisColorLoop.keys():\u000a            exec(paramName + '= thisColorLoop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "StimSetup"-------\u000a    t = 0\u000a    StimSetupClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    \u000a    # keep track of which components have finished\u000a    StimSetupComponents = []\u000a    for thisComponent in StimSetupComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "StimSetup"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = StimSetupClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in StimSetupComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "StimSetup"-------\u000a    for thisComponent in StimSetupComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 8 repeats of 'ColorLoop'\u000a\u000a# get names of stimulus parameters\u000aif ColorLoop.trialList in ([], [None], None):  params = []\u000aelse:  params = ColorLoop.trialList[0].keys()\u000a# save data for this loop\u000aColorLoop.saveAsExcel(filename + '.xlsx', sheetName='ColorLoop',\u000a    stimOut=params,\u000a    dataOut=['n','all_mean','all_std', 'all_raw'])\u000a\u000a#------Prepare to start Routine "instrPractice"-------\u000at = 0\u000ainstrPracticeClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aok1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000aok1.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstrPracticeComponents = []\u000ainstrPracticeComponents.append(instruct1)\u000ainstrPracticeComponents.append(ok1)\u000afor thisComponent in instrPracticeComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instrPractice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instrPracticeClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruct1* updates\u000a    if t >= 0.0 and instruct1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruct1.tStart = t  # underestimates by a little under one frame\u000a        instruct1.frameNStart = frameN  # exact frame index\u000a        instruct1.setAutoDraw(True)\u000a    \u000a    # *ok1* updates\u000a    if t >= 0.0 and ok1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        ok1.tStart = t  # underestimates by a little under one frame\u000a        ok1.frameNStart = frameN  # exact frame index\u000a        ok1.status = STARTED\u000a        # keyboard checking is just starting\u000a        ok1.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if ok1.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            ok1.keys = theseKeys[-1]  # just the last key pressed\u000a            ok1.rt = ok1.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instrPracticeComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instrPractice"-------\u000afor thisComponent in instrPracticeComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif ok1.keys in ['', [], None]:  # No response was made\u000a   ok1.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('ok1.keys',ok1.keys)\u000aif ok1.keys != None:  # we had a response\u000a    thisExp.addData('ok1.rt', ok1.rt)\u000athisExp.nextEntry()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apracticeTrials = data.TrialHandler(nReps=1.0, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('trialTypes3.xlsx'),\u000a    seed=None, name='practiceTrials')\u000athisExp.addLoop(practiceTrials)  # add the loop to the experiment\u000athisPracticeTrial = practiceTrials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPracticeTrial.rgb)\u000aif thisPracticeTrial != None:\u000a    for paramName in thisPracticeTrial.keys():\u000a        exec(paramName + '= thisPracticeTrial.' + paramName)\u000a\u000afor thisPracticeTrial in practiceTrials:\u000a    currentLoop = practiceTrials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPracticeTrial.rgb)\u000a    if thisPracticeTrial != None:\u000a        for paramName in thisPracticeTrial.keys():\u000a            exec(paramName + '= thisPracticeTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.500000)\u000a    # update component parameters for each repeat\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    image_2.setPos([xPos, yPos])\u000a    image_2.setImage(ShapeStimulus)\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(resp)\u000a    trialComponents.append(text)\u000a    trialComponents.append(image_2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *resp* updates\u000a        if t >= .5 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if resp.status == STARTED and t >= (.5 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['t', 'y', 'g', 'h'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(corrAns)) or (resp.keys == corrAns):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        if text.status == STARTED and t >= (0.0 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # *image_2* updates\u000a        if t >= .5 and image_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            image_2.tStart = t  # underestimates by a little under one frame\u000a            image_2.frameNStart = frameN  # exact frame index\u000a            image_2.setAutoDraw(True)\u000a        if image_2.status == STARTED and t >= (.5 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            image_2.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practiceTrials (TrialHandler)\u000a    practiceTrials.addData('resp.keys',resp.keys)\u000a    practiceTrials.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        practiceTrials.addData('resp.rt', resp.rt)\u000a    \u000a    #------Prepare to start Routine "feedback"-------\u000a    t = 0\u000a    feedbackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if resp.corr:#stored on last run routine\u000a      msg="Correct! RT=%.3f" %(resp.rt)\u000a    else:\u000a      msg="Oops! That was wrong"\u000a    feedback_2.setText(msg)\u000a    # keep track of which components have finished\u000a    feedbackComponents = []\u000a    feedbackComponents.append(feedback_2)\u000a    for thisComponent in feedbackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "feedback"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = feedbackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *feedback_2* updates\u000a        if t >= 0.0 and feedback_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            feedback_2.tStart = t  # underestimates by a little under one frame\u000a            feedback_2.frameNStart = frameN  # exact frame index\u000a            feedback_2.setAutoDraw(True)\u000a        if feedback_2.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            feedback_2.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in feedbackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "feedback"-------\u000a    for thisComponent in feedbackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1.0 repeats of 'practiceTrials'\u000a\u000a# get names of stimulus parameters\u000aif practiceTrials.trialList in ([], [None], None):  params = []\u000aelse:  params = practiceTrials.trialList[0].keys()\u000a# save data for this loop\u000apracticeTrials.saveAsExcel(filename + '.xlsx', sheetName='practiceTrials',\u000a    stimOut=params,\u000a    dataOut=['n','all_mean','all_std', 'all_raw'])\u000a\u000a#------Prepare to start Routine "instrMain"-------\u000at = 0\u000ainstrMainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aok2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000aok2.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstrMainComponents = []\u000ainstrMainComponents.append(instr2)\u000ainstrMainComponents.append(ok2)\u000afor thisComponent in instrMainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instrMain"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instrMainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr2* updates\u000a    if t >= 0.0 and instr2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr2.tStart = t  # underestimates by a little under one frame\u000a        instr2.frameNStart = frameN  # exact frame index\u000a        instr2.setAutoDraw(True)\u000a    \u000a    # *ok2* updates\u000a    if t >= 0.0 and ok2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        ok2.tStart = t  # underestimates by a little under one frame\u000a        ok2.frameNStart = frameN  # exact frame index\u000a        ok2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if ok2.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instrMainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instrMain"-------\u000afor thisComponent in instrMainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atrials = data.TrialHandler(nReps=4.0, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('trialTypes2.xlsx'),\u000a    seed=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experiment\u000athisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000aif thisTrial != None:\u000a    for paramName in thisTrial.keys():\u000a        exec(paramName + '= thisTrial.' + paramName)\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.500000)\u000a    # update component parameters for each repeat\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    image_2.setPos([xPos, yPos])\u000a    image_2.setImage(ShapeStimulus)\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(resp)\u000a    trialComponents.append(text)\u000a    trialComponents.append(image_2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *resp* updates\u000a        if t >= .5 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if resp.status == STARTED and t >= (.5 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['t', 'y', 'g', 'h'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(corrAns)) or (resp.keys == corrAns):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        if text.status == STARTED and t >= (0.0 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # *image_2* updates\u000a        if t >= .5 and image_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            image_2.tStart = t  # underestimates by a little under one frame\u000a            image_2.frameNStart = frameN  # exact frame index\u000a            image_2.setAutoDraw(True)\u000a        if image_2.status == STARTED and t >= (.5 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            image_2.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for trials (TrialHandler)\u000a    trials.addData('resp.keys',resp.keys)\u000a    trials.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        trials.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a    \u000a# completed 4.0 repeats of 'trials'\u000a\u000a# get names of stimulus parameters\u000aif trials.trialList in ([], [None], None):  params = []\u000aelse:  params = trials.trialList[0].keys()\u000a# save data for this loop\u000atrials.saveAsExcel(filename + '.xlsx', sheetName='trials',\u000a    stimOut=params,\u000a    dataOut=['n','all_mean','all_std', 'all_raw'])\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p41
sS'thisTrial'
p42
g1
(cpsychopy.data
TrialType
p43
c__builtin__
dict
p44
(dp45
VxPos
p46
I200
sVcorrAns
p47
Vy
sVlocation
p48
Vup_right
p49
sVShapeStimulus
p50
Vcrossorange.gif
p51
sVShape
p52
VSquare
p53
sVyPos
p54
I200
stRp55
sS'_exp'
p56
I242893392
sg10
S'practiceTrials'
p57
sg6
S'/Users/patrickbissett/OneDrive/Poldrack/TrainedInhibition/PsychoPy/LearningTask5.py'
p58
sS'thisRepN'
p59
I0
sg19
I01
sg20
g21
sS'data'
p60
g1
(cpsychopy.data
DataHandler
p61
g44
(dp62
S'ran'
p63
cnumpy.ma.core
_mareconstruct
p64
(cnumpy.ma.core
MaskedArray
p65
cnumpy
ndarray
p66
(I0
tp67
S'b'
tRp68
(I1
(I16
I1
tg27
(S'f4'
I0
I1
tRp69
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg16
cnumpy.core.multiarray
_reconstruct
p70
(g66
(I0
tS'b'
tRp71
(I1
(I16
I1
tg27
(S'O4'
I0
I1
tRp72
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp73
S'y'
aS'--'
p74
aS'--'
p75
aS'y'
aS'--'
p76
aS'--'
p77
aS'--'
p78
aS'--'
p79
aS'--'
p80
aS'--'
p81
aS'--'
p82
aS'h'
aS'--'
p83
aS'g'
aS'--'
p84
aS'--'
p85
atbsg17
g64
(g65
g66
g67
S'b'
tRp86
(I1
(I16
I1
tg69
I00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x00\x01\x01\x01\x01\x01\x01\x01\x00\x01\x00\x01\x01'
NtbsS'order'
p87
g64
(g65
g66
g67
S'b'
tRp88
(I1
(I16
I1
tg69
I00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80@\x00\x00@@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x00\x00\x01\x01\x01\x01\x01\x01\x01\x00\x01\x00\x01\x01'
Ntbsg18
g64
(g65
g66
g67
S'b'
tRp89
(I1
(I16
I1
tg69
I00
S'\xb0\xc4\xb3>\x00\x00\x00\x00\x00\x00\x00\x00 \xa3\xb3>\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\xc8\xb3>\x00\x00\x00\x00\xd4\xf5\x0c?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x00\x01\x01\x01\x01\x01\x01\x01\x00\x01\x00\x01\x01'
NtbstRp90
(dp91
S'isNumeric'
p92
(dp93
g63
I01
sg16
I00
sg18
I01
sg87
I01
sg17
I01
ssS'trials'
p94
g38
sS'dataTypes'
p95
(lp96
g63
ag87
ag16
ag17
ag18
asS'dataShape'
p97
(lp98
I16
aI1
asbsS'method'
p99
S'random'
p100
sS'sequenceIndices'
p101
g70
(g66
(I0
tS'b'
tRp102
(I1
(I16
I1
tg27
(S'i4'
I0
I1
tRp103
(I3
S'<'
NNNI-1
I-1
I0
tbI01
S'\r\x00\x00\x00\x00\x00\x00\x00\x0b\x00\x00\x00\x03\x00\x00\x00\x02\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0f\x00\x00\x00\x06\x00\x00\x00\x01\x00\x00\x00\x0c\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\x0e\x00\x00\x00'
tbsS'finished'
p104
I00
sS'nReps'
p105
I1
sS'nRemaining'
p106
I11
sS'trialList'
p107
(lp108
g1
(g43
g44
(dp109
g46
I200
sg47
Vy
sg48
g49
sg50
Vcrosscyan.gif
p110
sg52
VLine
p111
sg54
I200
stRp112
ag1
(g43
g44
(dp113
g46
I200
sg47
Vy
sg48
g49
sg50
Vcrossgray.gif
p114
sg52
VTriangle
p115
sg54
I200
stRp116
ag55
ag1
(g43
g44
(dp117
g46
I200
sg47
Vy
sg48
g49
sg50
Vcrossyellow.gif
p118
sg52
VCircle
p119
sg54
I200
stRp120
ag1
(g43
g44
(dp121
g46
I-200
sg47
Vt
sg48
Vup_left
p122
sg50
Vcirclegreen.gif
p123
sg52
g111
sg54
I200
stRp124
ag1
(g43
g44
(dp125
g46
I-200
sg47
Vt
sg48
g122
sg50
Vcirclemagenta.gif
p126
sg52
g115
sg54
I200
stRp127
ag1
(g43
g44
(dp128
g46
I-200
sg47
Vt
sg48
g122
sg50
Vcirclewhite.gif
p129
sg52
g53
sg54
I200
stRp130
ag1
(g43
g44
(dp131
g46
I-200
sg47
Vt
sg48
g122
sg50
Vcirclecyan.gif
p132
sg52
g119
sg54
I200
stRp133
ag1
(g43
g44
(dp134
g46
I200
sg47
Vh
sg48
Vdown_right
p135
sg50
Vdiamondgray.gif
p136
sg52
g111
sg54
I-200
stRp137
ag1
(g43
g44
(dp138
g46
I200
sg47
Vh
sg48
g135
sg50
Vdiamondorange.gif
p139
sg52
g115
sg54
I-200
stRp140
ag1
(g43
g44
(dp141
g46
I200
sg47
Vh
sg48
g135
sg50
Vdiamondwhite.gif
p142
sg52
g53
sg54
I-200
stRp143
ag1
(g43
g44
(dp144
g46
I200
sg47
Vh
sg48
g135
sg50
Vdiamondmagenta.gif
p145
sg52
g119
sg54
I-200
stRp146
ag1
(g43
g44
(dp147
g46
I-200
sg47
Vg
sg48
Vdown_left
p148
sg50
Vhexagonyellow.gif
p149
sg52
g111
sg54
I-200
stRp150
ag1
(g43
g44
(dp151
g46
I-200
sg47
Vg
sg48
g148
sg50
Vhexagonmagenta.gif
p152
sg52
g115
sg54
I-200
stRp153
ag1
(g43
g44
(dp154
g46
I-200
sg47
Vg
sg48
g148
sg50
Vhexagongreen.gif
p155
sg52
g53
sg54
I-200
stRp156
ag1
(g43
g44
(dp157
g46
I-200
sg47
Vg
sg48
g148
sg50
Vhexagongray.gif
p158
sg52
g119
sg54
I-200
stRp159
asS'seed'
p160
NsS'thisIndex'
p161
g26
(g103
S'\x02\x00\x00\x00'
tRp162
sS'thisN'
p163
I4
sS'thisTrialN'
p164
I4
sS'nTotal'
p165
I16
sS'_warnUseOfNext'
p166
I01
sbasS'saveWideText'
p167
I01
sS'thisEntry'
p168
(dp169
sS'version'
p170
S''
sS'_paramNamesSoFar'
p171
(lp172
VColor
p173
ag46
ag48
ag50
ag52
ag54
ag47
asS'entries'
p174
(lp175
(dp176
g30
I3
sS'ColorLoop.thisTrialN'
p177
I0
sS'ColorLoop.thisRepN'
p178
I0
sg173
Vmagenta
p179
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p180
g26
(g103
S'\x03\x00\x00\x00'
tRp181
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p182
I0
sa(dp183
g30
I3
sS'ColorLoop.thisTrialN'
p184
I1
sS'ColorLoop.thisRepN'
p185
I0
sg173
Vyellow
p186
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p187
g26
(g103
S'\x00\x00\x00\x00'
tRp188
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p189
I1
sa(dp190
g30
I3
sS'ColorLoop.thisTrialN'
p191
I2
sS'ColorLoop.thisRepN'
p192
I0
sg173
Vcyan
p193
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p194
g26
(g103
S'\x06\x00\x00\x00'
tRp195
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p196
I2
sa(dp197
g30
I3
sS'ColorLoop.thisTrialN'
p198
I3
sS'ColorLoop.thisRepN'
p199
I0
sg173
Vblue
p200
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p201
g26
(g103
S'\x07\x00\x00\x00'
tRp202
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p203
I3
sa(dp204
g30
I3
sS'ColorLoop.thisTrialN'
p205
I4
sS'ColorLoop.thisRepN'
p206
I0
sg173
Vgreen
p207
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p208
g26
(g103
S'\x04\x00\x00\x00'
tRp209
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p210
I4
sa(dp211
g30
I3
sS'ColorLoop.thisTrialN'
p212
I5
sS'ColorLoop.thisRepN'
p213
I0
sg173
Vwhite
p214
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p215
g26
(g103
S'\x01\x00\x00\x00'
tRp216
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p217
I5
sa(dp218
g30
I3
sS'ColorLoop.thisTrialN'
p219
I6
sS'ColorLoop.thisRepN'
p220
I0
sg173
Vorange
p221
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p222
g26
(g103
S'\x02\x00\x00\x00'
tRp223
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p224
I6
sa(dp225
g30
I3
sS'ColorLoop.thisTrialN'
p226
I7
sS'ColorLoop.thisRepN'
p227
I0
sg173
Vgray
p228
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p229
g26
(g103
S'\x05\x00\x00\x00'
tRp230
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p231
I7
sa(dp232
g30
I3
sS'ColorLoop.thisTrialN'
p233
I0
sS'ColorLoop.thisRepN'
p234
I1
sg173
g200
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p235
g26
(g103
S'\x07\x00\x00\x00'
tRp236
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p237
I8
sa(dp238
g30
I3
sS'ColorLoop.thisTrialN'
p239
I1
sS'ColorLoop.thisRepN'
p240
I1
sg173
g214
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p241
g26
(g103
S'\x01\x00\x00\x00'
tRp242
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p243
I9
sa(dp244
g30
I3
sS'ColorLoop.thisTrialN'
p245
I2
sS'ColorLoop.thisRepN'
p246
I1
sg173
g207
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p247
g26
(g103
S'\x04\x00\x00\x00'
tRp248
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p249
I10
sa(dp250
g30
I3
sS'ColorLoop.thisTrialN'
p251
I3
sS'ColorLoop.thisRepN'
p252
I1
sg173
g193
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p253
g26
(g103
S'\x06\x00\x00\x00'
tRp254
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p255
I11
sa(dp256
g30
I3
sS'ColorLoop.thisTrialN'
p257
I4
sS'ColorLoop.thisRepN'
p258
I1
sg173
g186
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p259
g26
(g103
S'\x00\x00\x00\x00'
tRp260
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p261
I12
sa(dp262
g30
I3
sS'ColorLoop.thisTrialN'
p263
I5
sS'ColorLoop.thisRepN'
p264
I1
sg173
g228
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p265
g26
(g103
S'\x05\x00\x00\x00'
tRp266
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p267
I13
sa(dp268
g30
I3
sS'ColorLoop.thisTrialN'
p269
I6
sS'ColorLoop.thisRepN'
p270
I1
sg173
g221
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p271
g26
(g103
S'\x02\x00\x00\x00'
tRp272
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p273
I14
sa(dp274
g30
I3
sS'ColorLoop.thisTrialN'
p275
I7
sS'ColorLoop.thisRepN'
p276
I1
sg173
g179
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p277
g26
(g103
S'\x03\x00\x00\x00'
tRp278
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p279
I15
sa(dp280
g30
I3
sS'ColorLoop.thisTrialN'
p281
I0
sS'ColorLoop.thisRepN'
p282
I2
sg173
g200
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p283
g26
(g103
S'\x07\x00\x00\x00'
tRp284
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p285
I16
sa(dp286
g30
I3
sS'ColorLoop.thisTrialN'
p287
I1
sS'ColorLoop.thisRepN'
p288
I2
sg173
g186
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p289
g26
(g103
S'\x00\x00\x00\x00'
tRp290
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p291
I17
sa(dp292
g30
I3
sS'ColorLoop.thisTrialN'
p293
I2
sS'ColorLoop.thisRepN'
p294
I2
sg173
g228
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p295
g26
(g103
S'\x05\x00\x00\x00'
tRp296
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p297
I18
sa(dp298
g30
I3
sS'ColorLoop.thisTrialN'
p299
I3
sS'ColorLoop.thisRepN'
p300
I2
sg173
g214
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p301
g26
(g103
S'\x01\x00\x00\x00'
tRp302
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p303
I19
sa(dp304
g30
I3
sS'ColorLoop.thisTrialN'
p305
I4
sS'ColorLoop.thisRepN'
p306
I2
sg173
g221
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p307
g26
(g103
S'\x02\x00\x00\x00'
tRp308
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p309
I20
sa(dp310
g30
I3
sS'ColorLoop.thisTrialN'
p311
I5
sS'ColorLoop.thisRepN'
p312
I2
sg173
g193
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p313
g26
(g103
S'\x06\x00\x00\x00'
tRp314
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p315
I21
sa(dp316
g30
I3
sS'ColorLoop.thisTrialN'
p317
I6
sS'ColorLoop.thisRepN'
p318
I2
sg173
g207
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p319
g26
(g103
S'\x04\x00\x00\x00'
tRp320
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p321
I22
sa(dp322
g30
I3
sS'ColorLoop.thisTrialN'
p323
I7
sS'ColorLoop.thisRepN'
p324
I2
sg173
g179
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p325
g26
(g103
S'\x03\x00\x00\x00'
tRp326
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p327
I23
sa(dp328
g30
I3
sS'ColorLoop.thisTrialN'
p329
I0
sS'ColorLoop.thisRepN'
p330
I3
sg173
g179
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p331
g26
(g103
S'\x03\x00\x00\x00'
tRp332
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p333
I24
sa(dp334
g30
I3
sS'ColorLoop.thisTrialN'
p335
I1
sS'ColorLoop.thisRepN'
p336
I3
sg173
g228
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p337
g26
(g103
S'\x05\x00\x00\x00'
tRp338
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p339
I25
sa(dp340
g30
I3
sS'ColorLoop.thisTrialN'
p341
I2
sS'ColorLoop.thisRepN'
p342
I3
sg173
g186
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p343
g26
(g103
S'\x00\x00\x00\x00'
tRp344
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p345
I26
sa(dp346
g30
I3
sS'ColorLoop.thisTrialN'
p347
I3
sS'ColorLoop.thisRepN'
p348
I3
sg173
g214
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p349
g26
(g103
S'\x01\x00\x00\x00'
tRp350
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p351
I27
sa(dp352
g30
I3
sS'ColorLoop.thisTrialN'
p353
I4
sS'ColorLoop.thisRepN'
p354
I3
sg173
g193
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p355
g26
(g103
S'\x06\x00\x00\x00'
tRp356
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p357
I28
sa(dp358
g30
I3
sS'ColorLoop.thisTrialN'
p359
I5
sS'ColorLoop.thisRepN'
p360
I3
sg173
g221
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p361
g26
(g103
S'\x02\x00\x00\x00'
tRp362
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p363
I29
sa(dp364
g30
I3
sS'ColorLoop.thisTrialN'
p365
I6
sS'ColorLoop.thisRepN'
p366
I3
sg173
g200
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p367
g26
(g103
S'\x07\x00\x00\x00'
tRp368
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p369
I30
sa(dp370
g30
I3
sS'ColorLoop.thisTrialN'
p371
I7
sS'ColorLoop.thisRepN'
p372
I3
sg173
g207
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p373
g26
(g103
S'\x04\x00\x00\x00'
tRp374
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p375
I31
sa(dp376
g30
I3
sS'ColorLoop.thisTrialN'
p377
I0
sS'ColorLoop.thisRepN'
p378
I4
sg173
g221
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p379
g26
(g103
S'\x02\x00\x00\x00'
tRp380
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p381
I32
sa(dp382
g30
I3
sS'ColorLoop.thisTrialN'
p383
I1
sS'ColorLoop.thisRepN'
p384
I4
sg173
g200
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p385
g26
(g103
S'\x07\x00\x00\x00'
tRp386
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p387
I33
sa(dp388
g30
I3
sS'ColorLoop.thisTrialN'
p389
I2
sS'ColorLoop.thisRepN'
p390
I4
sg173
g228
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p391
g26
(g103
S'\x05\x00\x00\x00'
tRp392
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p393
I34
sa(dp394
g30
I3
sS'ColorLoop.thisTrialN'
p395
I3
sS'ColorLoop.thisRepN'
p396
I4
sg173
g207
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p397
g26
(g103
S'\x04\x00\x00\x00'
tRp398
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p399
I35
sa(dp400
g30
I3
sS'ColorLoop.thisTrialN'
p401
I4
sS'ColorLoop.thisRepN'
p402
I4
sg173
g193
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p403
g26
(g103
S'\x06\x00\x00\x00'
tRp404
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p405
I36
sa(dp406
g30
I3
sS'ColorLoop.thisTrialN'
p407
I5
sS'ColorLoop.thisRepN'
p408
I4
sg173
g179
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p409
g26
(g103
S'\x03\x00\x00\x00'
tRp410
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p411
I37
sa(dp412
g30
I3
sS'ColorLoop.thisTrialN'
p413
I6
sS'ColorLoop.thisRepN'
p414
I4
sg173
g186
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p415
g26
(g103
S'\x00\x00\x00\x00'
tRp416
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p417
I38
sa(dp418
g30
I3
sS'ColorLoop.thisTrialN'
p419
I7
sS'ColorLoop.thisRepN'
p420
I4
sg173
g214
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p421
g26
(g103
S'\x01\x00\x00\x00'
tRp422
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p423
I39
sa(dp424
g30
I3
sS'ColorLoop.thisTrialN'
p425
I0
sS'ColorLoop.thisRepN'
p426
I5
sg173
g179
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p427
g26
(g103
S'\x03\x00\x00\x00'
tRp428
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p429
I40
sa(dp430
g30
I3
sS'ColorLoop.thisTrialN'
p431
I1
sS'ColorLoop.thisRepN'
p432
I5
sg173
g214
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p433
g26
(g103
S'\x01\x00\x00\x00'
tRp434
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p435
I41
sa(dp436
g30
I3
sS'ColorLoop.thisTrialN'
p437
I2
sS'ColorLoop.thisRepN'
p438
I5
sg173
g186
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p439
g26
(g103
S'\x00\x00\x00\x00'
tRp440
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p441
I42
sa(dp442
g30
I3
sS'ColorLoop.thisTrialN'
p443
I3
sS'ColorLoop.thisRepN'
p444
I5
sg173
g193
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p445
g26
(g103
S'\x06\x00\x00\x00'
tRp446
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p447
I43
sa(dp448
g30
I3
sS'ColorLoop.thisTrialN'
p449
I4
sS'ColorLoop.thisRepN'
p450
I5
sg173
g207
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p451
g26
(g103
S'\x04\x00\x00\x00'
tRp452
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p453
I44
sa(dp454
g30
I3
sS'ColorLoop.thisTrialN'
p455
I5
sS'ColorLoop.thisRepN'
p456
I5
sg173
g228
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p457
g26
(g103
S'\x05\x00\x00\x00'
tRp458
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p459
I45
sa(dp460
g30
I3
sS'ColorLoop.thisTrialN'
p461
I6
sS'ColorLoop.thisRepN'
p462
I5
sg173
g221
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p463
g26
(g103
S'\x02\x00\x00\x00'
tRp464
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p465
I46
sa(dp466
g30
I3
sS'ColorLoop.thisTrialN'
p467
I7
sS'ColorLoop.thisRepN'
p468
I5
sg173
g200
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p469
g26
(g103
S'\x07\x00\x00\x00'
tRp470
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p471
I47
sa(dp472
g30
I3
sS'ColorLoop.thisTrialN'
p473
I0
sS'ColorLoop.thisRepN'
p474
I6
sg173
g228
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p475
g26
(g103
S'\x05\x00\x00\x00'
tRp476
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p477
I48
sa(dp478
g30
I3
sS'ColorLoop.thisTrialN'
p479
I1
sS'ColorLoop.thisRepN'
p480
I6
sg173
g200
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p481
g26
(g103
S'\x07\x00\x00\x00'
tRp482
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p483
I49
sa(dp484
g30
I3
sS'ColorLoop.thisTrialN'
p485
I2
sS'ColorLoop.thisRepN'
p486
I6
sg173
g207
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p487
g26
(g103
S'\x04\x00\x00\x00'
tRp488
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p489
I50
sa(dp490
g30
I3
sS'ColorLoop.thisTrialN'
p491
I3
sS'ColorLoop.thisRepN'
p492
I6
sg173
g193
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p493
g26
(g103
S'\x06\x00\x00\x00'
tRp494
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p495
I51
sa(dp496
g30
I3
sS'ColorLoop.thisTrialN'
p497
I4
sS'ColorLoop.thisRepN'
p498
I6
sg173
g214
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p499
g26
(g103
S'\x01\x00\x00\x00'
tRp500
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p501
I52
sa(dp502
g30
I3
sS'ColorLoop.thisTrialN'
p503
I5
sS'ColorLoop.thisRepN'
p504
I6
sg173
g179
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p505
g26
(g103
S'\x03\x00\x00\x00'
tRp506
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p507
I53
sa(dp508
g30
I3
sS'ColorLoop.thisTrialN'
p509
I6
sS'ColorLoop.thisRepN'
p510
I6
sg173
g186
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p511
g26
(g103
S'\x00\x00\x00\x00'
tRp512
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p513
I54
sa(dp514
g30
I3
sS'ColorLoop.thisTrialN'
p515
I7
sS'ColorLoop.thisRepN'
p516
I6
sg173
g221
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p517
g26
(g103
S'\x02\x00\x00\x00'
tRp518
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p519
I55
sa(dp520
g30
I3
sS'ColorLoop.thisTrialN'
p521
I0
sS'ColorLoop.thisRepN'
p522
I7
sg173
g179
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p523
g26
(g103
S'\x03\x00\x00\x00'
tRp524
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p525
I56
sa(dp526
g30
I3
sS'ColorLoop.thisTrialN'
p527
I1
sS'ColorLoop.thisRepN'
p528
I7
sg173
g221
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p529
g26
(g103
S'\x02\x00\x00\x00'
tRp530
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p531
I57
sa(dp532
g30
I3
sS'ColorLoop.thisTrialN'
p533
I2
sS'ColorLoop.thisRepN'
p534
I7
sg173
g228
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p535
g26
(g103
S'\x05\x00\x00\x00'
tRp536
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p537
I58
sa(dp538
g30
I3
sS'ColorLoop.thisTrialN'
p539
I3
sS'ColorLoop.thisRepN'
p540
I7
sg173
g186
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p541
g26
(g103
S'\x00\x00\x00\x00'
tRp542
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p543
I59
sa(dp544
g30
I3
sS'ColorLoop.thisTrialN'
p545
I4
sS'ColorLoop.thisRepN'
p546
I7
sg173
g200
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p547
g26
(g103
S'\x07\x00\x00\x00'
tRp548
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p549
I60
sa(dp550
g30
I3
sS'ColorLoop.thisTrialN'
p551
I5
sS'ColorLoop.thisRepN'
p552
I7
sg173
g207
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p553
g26
(g103
S'\x04\x00\x00\x00'
tRp554
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p555
I61
sa(dp556
g30
I3
sS'ColorLoop.thisTrialN'
p557
I6
sS'ColorLoop.thisRepN'
p558
I7
sg173
g214
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p559
g26
(g103
S'\x01\x00\x00\x00'
tRp560
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p561
I62
sa(dp562
g30
I3
sS'ColorLoop.thisTrialN'
p563
I7
sS'ColorLoop.thisRepN'
p564
I7
sg173
g193
sg24
V
sg33
g34
sg25
g29
sS'ColorLoop.thisIndex'
p565
g26
(g103
S'\x06\x00\x00\x00'
tRp566
sg22
g11
sg31
g32
sg23
V
sS'ColorLoop.thisN'
p567
I63
sa(dp568
g30
I3
sg23
V
sg15
F1.6140999794006348
sg24
V
sg25
g29
sg22
g11
sg14
S'space'
p569
sg31
g32
sg33
g34
sa(dp570
g30
I3
sg16
S'g'
sg46
I-200
sg47
Vg
sg50
g152
sg17
I1
sg18
F0.55062603950500488
sg24
V
sg33
g34
sS'practiceTrials.thisN'
p571
I0
sg54
I-200
sg25
g29
sg31
g32
sg52
g115
sg22
g11
sS'practiceTrials.thisTrialN'
p572
I0
sS'practiceTrials.thisIndex'
p573
g26
(g103
S'\r\x00\x00\x00'
tRp574
sS'practiceTrials.thisRepN'
p575
I0
sg23
V
sg48
g148
sa(dp576
g30
I3
sg16
S'y'
sg46
I200
sg47
Vy
sg50
g110
sg17
I1
sg18
F0.35110998153686523
sg24
V
sg33
g34
sS'practiceTrials.thisN'
p577
I1
sg54
I200
sg25
g29
sg31
g32
sg52
g111
sg22
g11
sS'practiceTrials.thisTrialN'
p578
I1
sS'practiceTrials.thisIndex'
p579
g26
(g103
S'\x00\x00\x00\x00'
tRp580
sS'practiceTrials.thisRepN'
p581
I0
sg23
V
sg48
g49
sa(dp582
g30
I3
sg16
S'h'
sg46
I200
sg47
Vh
sg50
g145
sg17
I1
sg18
F0.3511359691619873
sg24
V
sg33
g34
sS'practiceTrials.thisN'
p583
I2
sg54
I-200
sg25
g29
sg31
g32
sg52
g119
sg22
g11
sS'practiceTrials.thisTrialN'
p584
I2
sS'practiceTrials.thisIndex'
p585
g26
(g103
S'\x0b\x00\x00\x00'
tRp586
sS'practiceTrials.thisRepN'
p587
I0
sg23
V
sg48
g135
sa(dp588
g30
I3
sg16
S'y'
sg46
I200
sg47
Vy
sg50
g118
sg17
I1
sg18
F0.35085391998291016
sg24
V
sg33
g34
sS'practiceTrials.thisN'
p589
I3
sg54
I200
sg25
g29
sg31
g32
sg52
g119
sg22
g11
sS'practiceTrials.thisTrialN'
p590
I3
sS'practiceTrials.thisIndex'
p591
g26
(g103
S'\x03\x00\x00\x00'
tRp592
sS'practiceTrials.thisRepN'
p593
I0
sg23
V
sg48
g49
sasS'loops'
p594
(lp595
g1
(g37
g3
NtRp596
(dp597
g40
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.03), Wed Mar  4 09:28:30 2015\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'LearningTask'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'gender (m/f)':'', 'age':'', 'session':03}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + u'data' + os.sep + '%s_%s' %(expInfo['participant'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.WARNING)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "StimSetup"\u000aStimSetupClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "instrPractice"\u000ainstrPracticeClock = core.Clock()\u000ainstruct1 = visual.TextStim(win=win, ori=0, name='instruct1',\u000a    text='A shape stimulus will appear on every trial. \u005cn\u005cnIf it appears in the upper right quadrant, PRESS Y\u005cn\u005cnIf it appears in the lower right quadrant, PRESS H\u005cn\u005cnIf it appears in the lower left quadrant, PRESS G\u005cn\u005cnIf it appears in the upper left quadrant, PRESS T\u005cn\u005cnPress any key when you are ready to proceed. ',    font='Arial',\u000a    pos=[0, 0], height=0.07, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage_2 = visual.ImageStim(win=win, name='image_2',units='pix', \u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[101, 101],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "feedback"\u000afeedbackClock = core.Clock()\u000a#msg variable just needs some value at start\u000amsg=''\u000afeedback_2 = visual.TextStim(win=win, ori=0, name='feedback_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "instrMain"\u000ainstrMainClock = core.Clock()\u000ainstr2 = visual.TextStim(win=win, ori=0, name='instr2',\u000a    text="OK, ready to start the main experiment?\u005cn\u005cnRemember, press;\u005cn - 'S' if the SMALL letters are S\u005cn - 'H' if the SMALL letters are H\u005cn\u005cnTry to respond as quickly and as accurately as possible.\u005cn\u005cnWhen you are ready to proceed press any key.",    font='Arial',\u000a    pos=[0, 0], height=0.075, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aimage_2 = visual.ImageStim(win=win, name='image_2',units='pix', \u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[101, 101],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a# set up handler to look after randomisation of conditions etc\u000aColorLoop = data.TrialHandler(nReps=8, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('Color.xlsx'),\u000a    seed=None, name='ColorLoop')\u000athisExp.addLoop(ColorLoop)  # add the loop to the experiment\u000athisColorLoop = ColorLoop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisColorLoop.rgb)\u000aif thisColorLoop != None:\u000a    for paramName in thisColorLoop.keys():\u000a        exec(paramName + '= thisColorLoop.' + paramName)\u000a\u000afor thisColorLoop in ColorLoop:\u000a    currentLoop = ColorLoop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisColorLoop.rgb)\u000a    if thisColorLoop != None:\u000a        for paramName in thisColorLoop.keys():\u000a            exec(paramName + '= thisColorLoop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "StimSetup"-------\u000a    t = 0\u000a    StimSetupClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    \u000a    # keep track of which components have finished\u000a    StimSetupComponents = []\u000a    for thisComponent in StimSetupComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "StimSetup"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = StimSetupClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in StimSetupComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "StimSetup"-------\u000a    for thisComponent in StimSetupComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 8 repeats of 'ColorLoop'\u000a\u000a# get names of stimulus parameters\u000aif ColorLoop.trialList in ([], [None], None):  params = []\u000aelse:  params = ColorLoop.trialList[0].keys()\u000a# save data for this loop\u000aColorLoop.saveAsExcel(filename + '.xlsx', sheetName='ColorLoop',\u000a    stimOut=params,\u000a    dataOut=['n','all_mean','all_std', 'all_raw'])\u000a\u000a#------Prepare to start Routine "instrPractice"-------\u000at = 0\u000ainstrPracticeClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aok1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000aok1.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstrPracticeComponents = []\u000ainstrPracticeComponents.append(instruct1)\u000ainstrPracticeComponents.append(ok1)\u000afor thisComponent in instrPracticeComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instrPractice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instrPracticeClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruct1* updates\u000a    if t >= 0.0 and instruct1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruct1.tStart = t  # underestimates by a little under one frame\u000a        instruct1.frameNStart = frameN  # exact frame index\u000a        instruct1.setAutoDraw(True)\u000a    \u000a    # *ok1* updates\u000a    if t >= 0.0 and ok1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        ok1.tStart = t  # underestimates by a little under one frame\u000a        ok1.frameNStart = frameN  # exact frame index\u000a        ok1.status = STARTED\u000a        # keyboard checking is just starting\u000a        ok1.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if ok1.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            ok1.keys = theseKeys[-1]  # just the last key pressed\u000a            ok1.rt = ok1.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instrPracticeComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instrPractice"-------\u000afor thisComponent in instrPracticeComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif ok1.keys in ['', [], None]:  # No response was made\u000a   ok1.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('ok1.keys',ok1.keys)\u000aif ok1.keys != None:  # we had a response\u000a    thisExp.addData('ok1.rt', ok1.rt)\u000athisExp.nextEntry()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apracticeTrials = data.TrialHandler(nReps=1.0, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('trialTypes3.xlsx'),\u000a    seed=None, name='practiceTrials')\u000athisExp.addLoop(practiceTrials)  # add the loop to the experiment\u000athisPracticeTrial = practiceTrials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPracticeTrial.rgb)\u000aif thisPracticeTrial != None:\u000a    for paramName in thisPracticeTrial.keys():\u000a        exec(paramName + '= thisPracticeTrial.' + paramName)\u000a\u000afor thisPracticeTrial in practiceTrials:\u000a    currentLoop = practiceTrials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPracticeTrial.rgb)\u000a    if thisPracticeTrial != None:\u000a        for paramName in thisPracticeTrial.keys():\u000a            exec(paramName + '= thisPracticeTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.500000)\u000a    # update component parameters for each repeat\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    image_2.setPos([xPos, yPos])\u000a    image_2.setImage(ShapeStimulus)\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(resp)\u000a    trialComponents.append(text)\u000a    trialComponents.append(image_2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *resp* updates\u000a        if t >= .5 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if resp.status == STARTED and t >= (.5 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['t', 'y', 'g', 'h'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(corrAns)) or (resp.keys == corrAns):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        if text.status == STARTED and t >= (0.0 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # *image_2* updates\u000a        if t >= .5 and image_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            image_2.tStart = t  # underestimates by a little under one frame\u000a            image_2.frameNStart = frameN  # exact frame index\u000a            image_2.setAutoDraw(True)\u000a        if image_2.status == STARTED and t >= (.5 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            image_2.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practiceTrials (TrialHandler)\u000a    practiceTrials.addData('resp.keys',resp.keys)\u000a    practiceTrials.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        practiceTrials.addData('resp.rt', resp.rt)\u000a    \u000a    #------Prepare to start Routine "feedback"-------\u000a    t = 0\u000a    feedbackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if resp.corr:#stored on last run routine\u000a      msg="Correct! RT=%.3f" %(resp.rt)\u000a    else:\u000a      msg="Oops! That was wrong"\u000a    feedback_2.setText(msg)\u000a    # keep track of which components have finished\u000a    feedbackComponents = []\u000a    feedbackComponents.append(feedback_2)\u000a    for thisComponent in feedbackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "feedback"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = feedbackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *feedback_2* updates\u000a        if t >= 0.0 and feedback_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            feedback_2.tStart = t  # underestimates by a little under one frame\u000a            feedback_2.frameNStart = frameN  # exact frame index\u000a            feedback_2.setAutoDraw(True)\u000a        if feedback_2.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            feedback_2.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in feedbackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "feedback"-------\u000a    for thisComponent in feedbackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1.0 repeats of 'practiceTrials'\u000a\u000a# get names of stimulus parameters\u000aif practiceTrials.trialList in ([], [None], None):  params = []\u000aelse:  params = practiceTrials.trialList[0].keys()\u000a# save data for this loop\u000apracticeTrials.saveAsExcel(filename + '.xlsx', sheetName='practiceTrials',\u000a    stimOut=params,\u000a    dataOut=['n','all_mean','all_std', 'all_raw'])\u000a\u000a#------Prepare to start Routine "instrMain"-------\u000at = 0\u000ainstrMainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aok2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000aok2.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstrMainComponents = []\u000ainstrMainComponents.append(instr2)\u000ainstrMainComponents.append(ok2)\u000afor thisComponent in instrMainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instrMain"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instrMainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr2* updates\u000a    if t >= 0.0 and instr2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr2.tStart = t  # underestimates by a little under one frame\u000a        instr2.frameNStart = frameN  # exact frame index\u000a        instr2.setAutoDraw(True)\u000a    \u000a    # *ok2* updates\u000a    if t >= 0.0 and ok2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        ok2.tStart = t  # underestimates by a little under one frame\u000a        ok2.frameNStart = frameN  # exact frame index\u000a        ok2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if ok2.status == STARTED:\u000a        theseKeys = event.getKeys()\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instrMainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instrMain"-------\u000afor thisComponent in instrMainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atrials = data.TrialHandler(nReps=4.0, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('trialTypes2.xlsx'),\u000a    seed=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experiment\u000athisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000aif thisTrial != None:\u000a    for paramName in thisTrial.keys():\u000a        exec(paramName + '= thisTrial.' + paramName)\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.500000)\u000a    # update component parameters for each repeat\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    image_2.setPos([xPos, yPos])\u000a    image_2.setImage(ShapeStimulus)\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(resp)\u000a    trialComponents.append(text)\u000a    trialComponents.append(image_2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *resp* updates\u000a        if t >= .5 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if resp.status == STARTED and t >= (.5 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['t', 'y', 'g', 'h'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(corrAns)) or (resp.keys == corrAns):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        if text.status == STARTED and t >= (0.0 + (1.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # *image_2* updates\u000a        if t >= .5 and image_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            image_2.tStart = t  # underestimates by a little under one frame\u000a            image_2.frameNStart = frameN  # exact frame index\u000a            image_2.setAutoDraw(True)\u000a        if image_2.status == STARTED and t >= (.5 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            image_2.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for trials (TrialHandler)\u000a    trials.addData('resp.keys',resp.keys)\u000a    trials.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        trials.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a    \u000a# completed 4.0 repeats of 'trials'\u000a\u000a# get names of stimulus parameters\u000aif trials.trialList in ([], [None], None):  params = []\u000aelse:  params = trials.trialList[0].keys()\u000a# save data for this loop\u000atrials.saveAsExcel(filename + '.xlsx', sheetName='trials',\u000a    stimOut=params,\u000a    dataOut=['n','all_mean','all_std', 'all_raw'])\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p598
sg42
(lp599
sg56
I242893392
sg10
S'ColorLoop'
p600
sg6
g58
sg59
I8
sg19
I01
sg20
g21
sg60
g1
(g61
g44
(dp601
g63
g64
(g65
g66
g67
S'b'
tRp602
(I1
(I8
I8
tg69
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg87
g64
(g65
g66
g67
S'b'
tRp603
(I1
(I8
I8
tg69
I00
S'\x00\x00\x80?\x00\x00@A\x00\x00\x88A\x00\x00\xd0A\x00\x00\x18B\x00\x00(B\x00\x00XB\x00\x00lB\x00\x00\xa0@\x00\x00\x10A\x00\x00\x98A\x00\x00\xd8A\x00\x00\x1cB\x00\x00$B\x00\x00PB\x00\x00xB\x00\x00\xc0@\x00\x00`A\x00\x00\xa0A\x00\x00\xe8A\x00\x00\x00B\x00\x008B\x00\x00\\B\x00\x00dB\x00\x00\x00\x00\x00\x00pA\x00\x00\xb8A\x00\x00\xc0A\x00\x00\x14B\x00\x00 B\x00\x00TB\x00\x00`B\x00\x00\x80@\x00\x00 A\x00\x00\xb0A\x00\x00\xf8A\x00\x00\x0cB\x00\x000B\x00\x00HB\x00\x00tB\x00\x00\xe0@\x00\x00PA\x00\x00\x90A\x00\x00\xc8A\x00\x00\x08B\x00\x004B\x00\x00@B\x00\x00hB\x00\x00\x00@\x00\x000A\x00\x00\xa8A\x00\x00\xe0A\x00\x00\x10B\x00\x00,B\x00\x00LB\x00\x00|B\x00\x00@@\x00\x00\x00A\x00\x00\x80A\x00\x00\xf0A\x00\x00\x04B\x00\x00<B\x00\x00DB\x00\x00pB'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp604
(dp605
g92
(dp606
g63
I01
sg87
I01
ssg94
g596
sg95
(lp607
g63
ag87
asg97
(lp608
I8
aI8
asbsg99
g100
sg101
g70
(g66
(I0
tS'b'
tRp609
(I1
(I8
I8
tg103
I01
S'\x03\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x04\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x07\x00\x00\x00\x01\x00\x00\x00\x04\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x06\x00\x00\x00\x04\x00\x00\x00\x03\x00\x00\x00\x03\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x06\x00\x00\x00\x02\x00\x00\x00\x07\x00\x00\x00\x04\x00\x00\x00\x02\x00\x00\x00\x07\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\x06\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x02\x00\x00\x00\x07\x00\x00\x00\x05\x00\x00\x00\x07\x00\x00\x00\x04\x00\x00\x00\x06\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x07\x00\x00\x00\x04\x00\x00\x00\x01\x00\x00\x00\x06\x00\x00\x00'
tbsg104
I01
sg105
I8
sg106
I-1
sg107
(lp610
g1
(g43
g44
(dp611
g173
g186
stRp612
ag1
(g43
g44
(dp613
g173
g214
stRp614
ag1
(g43
g44
(dp615
g173
g221
stRp616
ag1
(g43
g44
(dp617
g173
g179
stRp618
ag1
(g43
g44
(dp619
g173
g207
stRp620
ag1
(g43
g44
(dp621
g173
g228
stRp622
ag1
(g43
g44
(dp623
g173
g193
stRp624
ag1
(g43
g44
(dp625
g173
g200
stRp626
asg160
Nsg161
g566
sg163
I64
sg164
I0
sg165
I64
sg166
I01
sbag38
asS'savePickle'
p627
I01
sb.